'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

/**
 * Fetch from the NextBus XML Feed using the given command, host, protocol, and query parameters,
 * and parse the resulting XML.
 */
var fetchNextBusXML = function () {
  var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(_ref2) {
    var command = _ref2.command,
        host = _ref2.host,
        onRequest = _ref2.onRequest,
        protocol = _ref2.protocol,
        query = _ref2.query;
    var uri, response;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            uri = _url2.default.format({
              host: host,
              protocol: protocol,
              pathname: '/service/publicXMLFeed',
              query: (0, _extends3.default)({ command: command }, query)
            });

            onRequest(uri);
            _context.next = 4;
            return (0, _isomorphicFetch2.default)(uri);

          case 4:
            response = _context.sent;
            _context.t0 = _parseXML2.default;
            _context.next = 8;
            return response.text();

          case 8:
            _context.t1 = _context.sent;
            return _context.abrupt('return', (0, _context.t0)(_context.t1));

          case 10:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function fetchNextBusXML(_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * Create a NextBus API object which will connect to the NextBus XML Feed served on the given
 * host and port, defaulting to the publicly-hosted instance at http://webservices.nextbus.com
 */


exports.default = nextbus;

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _parseXML = require('./parseXML');

var _parseXML2 = _interopRequireDefault(_parseXML);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function nextbus() {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref3$host = _ref3.host,
      host = _ref3$host === undefined ? 'webservices.nextbus.com' : _ref3$host,
      _ref3$onRequest = _ref3.onRequest,
      onRequest = _ref3$onRequest === undefined ? function () {} : _ref3$onRequest,
      _ref3$protocol = _ref3.protocol,
      protocol = _ref3$protocol === undefined ? 'http:' : _ref3$protocol;

  return {
    getAgencies: function getAgencies() {
      var _this = this;

      return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
        var xml;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return fetchNextBusXML({
                  command: 'agencyList',
                  host: host,
                  onRequest: onRequest,
                  protocol: protocol
                });

              case 2:
                xml = _context2.sent;
                return _context2.abrupt('return', xml.body.agency.map(function (node) {
                  return node.$;
                }));

              case 4:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, _this);
      }))();
    },
    getRoute: function getRoute(agencyTag, routeTag) {
      var _this2 = this;

      var includeNonUIDirections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var includePaths = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
        var xml, stops;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return fetchNextBusXML({
                  command: 'routeConfig',
                  host: host,
                  onRequest: onRequest,
                  protocol: protocol,
                  query: (0, _extends3.default)({
                    a: agencyTag,
                    r: routeTag
                  }, includeNonUIDirections ? { verbose: '' } : {}, !includePaths ? { terse: '' } : {})
                });

              case 2:
                xml = _context3.sent;
                stops = xml.body.route[0].stop.map(function (stop) {
                  return (0, _extends3.default)({}, stop.$, {
                    lat: Number.parseFloat(stop.$.lat),
                    lon: Number.parseFloat(stop.$.lon)
                  });
                });
                return _context3.abrupt('return', (0, _extends3.default)({}, xml.body.route[0].$, {
                  latMax: Number.parseFloat(xml.body.route[0].$.latMax),
                  latMin: Number.parseFloat(xml.body.route[0].$.latMin),
                  lonMax: Number.parseFloat(xml.body.route[0].$.lonMax),
                  lonMin: Number.parseFloat(xml.body.route[0].$.lonMin),
                  directions: xml.body.route[0].direction.map(function (direction) {
                    return (0, _extends3.default)({}, direction.$, {
                      useForUI: direction.$.useForUI === 'true',
                      stops: direction.stop.map(function (dirStop) {
                        return stops.find(function (stop) {
                          return stop.tag === dirStop.$.tag;
                        });
                      })
                    });
                  }),
                  paths: xml.body.route[0].path.map(function (pth) {
                    return pth.point.map(function (point) {
                      return {
                        lat: Number.parseFloat(point.$.lat),
                        lon: Number.parseFloat(point.$.lon)
                      };
                    });
                  }),
                  stops: stops
                }));

              case 5:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, _this2);
      }))();
    },
    getRoutes: function getRoutes(agencyTag) {
      var _this3 = this;

      return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
        var xml;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return fetchNextBusXML({
                  command: 'routeList',
                  host: host,
                  onRequest: onRequest,
                  protocol: protocol,
                  query: { a: agencyTag }
                });

              case 2:
                xml = _context4.sent;
                return _context4.abrupt('return', xml.body.route.map(function (node) {
                  return node.$;
                }));

              case 4:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, _this3);
      }))();
    }
  };
}